(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{509:function(s,r,t){"use strict";t.r(r);var a=t(6),_=Object(a.a)({},(function(){var s=this,r=s.$createElement,t=s._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h2",{attrs:{id:"redis规避缓存穿透、缓存击穿和缓存雪崩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis规避缓存穿透、缓存击穿和缓存雪崩"}},[s._v("#")]),s._v(" Redis规避缓存穿透、缓存击穿和缓存雪崩")]),s._v(" "),t("p",[s._v("在日常的开发中，我们通常会将Redis作为缓存来提高响应速度，减少数据库的压力，但是在实际开发中一下几种情况，需要我们特别注意：")]),s._v(" "),t("p",[t("strong",[s._v("缓存穿透")]),s._v("、"),t("strong",[s._v("缓存击穿")]),s._v("、"),t("strong",[s._v("缓存雪崩")])]),s._v(" "),t("h3",{attrs:{id:"_1、缓存穿透"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、缓存穿透"}},[s._v("#")]),s._v(" 1、缓存穿透")]),s._v(" "),t("p",[s._v("何为穿透：从字面意思上来说，是从其中穿过，直达目标。在这里我们可以理解为redis并没有起到缓存的效果，让请求直接落到了数据库。")]),s._v(" "),t("p",[s._v("这种情况实际业务场景是这样：当请求查询数据库并不存在的数据时，先查redis中是否存在？不存在直接查询")]),s._v(" "),t("p",[s._v("数据库是否存在。")]),s._v(" "),t("p",[s._v("当大量请求查询不存在数据时，按照上述的业务场景势必会增加数据库的压力，影响整个业务性能。")]),s._v(" "),t("p",[s._v("通过上面的分析我们发现redis并没有起到有效缓存的作用，我们一般称这种现象为"),t("em",[s._v("缓存穿透")])]),s._v(" "),t("h4",{attrs:{id:"解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[s._v("#")]),s._v(" 解决方案")]),s._v(" "),t("p",[s._v("缓存穿透的本质是redis并没有启动应有的缓存作用，所以针对这个漏洞特点我们需要让redis真正起到缓存的效果，一般的做法：将数据库中不存在的数据也存入到redis中，并且设置一个适当的过期时间，这样即使大量请求也直接回落到redis，而不会穿透redis,直接到达数据库。")]),s._v(" "),t("h3",{attrs:{id:"_2、缓存击穿"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、缓存击穿"}},[s._v("#")]),s._v(" 2、缓存击穿")]),s._v(" "),t("p",[s._v("缓存击穿的业务场景和缓存穿透的类似，只是业务类型不一样，缓存击穿主要针对数据库存在的数据，当某个时间点在redis中过期了，此时刚好有大量请求进入redis，在redis中没有获取到数据，直接又去查询数据库了，这时又会对数据库造成不小的压力。")]),s._v(" "),t("p",[s._v("实际业务场景如：瞬时10000个请求同时进入，存在并发。查询某个公共的数据资源，此时数据在redis中过期，如果不做相应处理，会有几乎1000个请求同时请求数据库，这个压力还是有的。")]),s._v(" "),t("h4",{attrs:{id:"解决方案-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-2"}},[s._v("#")]),s._v(" 解决方案")]),s._v(" "),t("p",[s._v("针对这种情况，我们需要改变请求数据顺序，理想状态下的设想是第1个请求，从数据库中取到数据后，存入redis中，剩余9999个请求，都从redis中获取。要想达到这种情况，我们应该进行加锁操作。")]),s._v(" "),t("h3",{attrs:{id:"_3、缓存雪崩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、缓存雪崩"}},[s._v("#")]),s._v(" 3、缓存雪崩")]),s._v(" "),t("p",[s._v("缓存雪崩一般指的是redis中绝大多数数据同时过期，而此时依然有大量请求来到，缓存无法命中，又对数据库造成压力，这种雪崩可能是致命的。")]),s._v(" "),t("p",[s._v("为什么会存在大量数据同时过期，这种一般常见于活动大促批量上新，那此时肯定是同时进入redis缓存中的，那么失效的时间也可能是一致的。")]),s._v(" "),t("p",[s._v("缓存雪崩不外乎两种情况：数据过期或者redis节点宕机。")]),s._v(" "),t("h4",{attrs:{id:"解决方案-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-3"}},[s._v("#")]),s._v(" 解决方案")]),s._v(" "),t("p",[s._v("一般常见做法是设置随机过期时间或者设置永不过期，当然我们需要结合具体的业务场景来针对性的设置。")]),s._v(" "),t("h3",{attrs:{id:"_4、关注微信公众号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、关注微信公众号"}},[s._v("#")]),s._v(" 4、关注微信公众号")]),s._v(" "),t("p",[s._v("关注微信公众号 "),t("strong",[s._v("老夫撸代码")]),s._v(" 让你开发不迷路。"),t("br"),s._v(" "),t("img",{attrs:{src:"/uploads/20200202/d7738bb673b081967caaa3dead6a777d.jpeg",alt:"输入图片说明",title:"在这里输入图片标题"}})])])}),[],!1,null,null,null);r.default=_.exports}}]);